if has('nvim')
    let g:python2_host_prog = "/usr/bin/python2"
    let g:python3_host_prog = "/usr/bin/python3"
    if has('mac')
        let g:python3_host_prog = "/usr/local/bin/python3"
    elseif has('unix')
        let g:python3_host_prog = "/usr/bin/python3"
    endif
    let g:python_host_skip_check = 1
    let g:python3_host_skip_check = 1

    set mouse=a
    tnoremap <Esc> <C-\><C-n>
    "Restore cursor to file position in previous editing session
    set viminfo='10,\"100,:20,%,n~/.nviminfo
    au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif
else
    "Restore cursor to file position in previous editing session
    set viminfo='10,\"100,:20,%,n~/.viminfo
    au BufReadPost * if line("'\"") > 0|if line("'\"") <= line("$")|exe("norm '\"")|else|exe "norm $"|endif|endif
endif


if has('nvim')
    call plug#begin('~/.config/nvim/plugged')
elseif
    call plug#begin('~/.vim/plugged')
endif

"" beautiful ui
Plug 'altercation/vim-colors-solarized'
Plug 'ryanoasis/vim-devicons'
Plug 'mhinz/vim-startify'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'vim-ctrlspace/vim-ctrlspace'
Plug 'luochen1990/rainbow'


"" file navigation
Plug 'derekwyatt/vim-fswitch'
Plug 'scrooloose/nerdtree'
Plug 'jistr/vim-nerdtree-tabs'

"" c related
Plug 'Twinside/vim-cuteErrorMarker'
Plug 'Chiel92/vim-autoformat'

"" code comment
Plug 'scrooloose/nerdcommenter'
Plug 'vim-scripts/DoxygenToolkit.vim'

"" code editing enhancement
Plug 'SirVer/ultisnips'
Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
Plug 'honza/vim-snippets'
Plug 'neoclide/coc.nvim', {
    \ 'tag': '*',
    \ 'do': { -> coc#util#install()} 
    \}
Plug 'autozimu/LanguageClient-neovim', {
    \ 'on': [],
    \ 'branch': 'next',
    \ 'do': 'bash install.sh',
    \ }

"" awesome edit 
Plug 'junegunn/vim-easy-align'
Plug 'terryma/vim-multiple-cursors'
Plug 'vim-scripts/VisIncr'
Plug 'jiangmiao/auto-pairs'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-commentary', { 'on': [] }

"" code navigation
Plug 'majutsushi/tagbar'
Plug 'bbchung/gtags.vim'
Plug 'terryma/vim-expand-region'
Plug 'kshenoy/vim-signature'

" git
Plug 'gregsexton/gitv'
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'tpope/vim-fugitive'
Plug 'mhinz/vim-signify'

"" Search
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'tacahiroy/ctrlp-funky'
Plug 'mileszs/ack.vim'

"" Motion
Plug 'justinmk/vim-sneak', { 'on': [] }
Plug 'easymotion/vim-easymotion'
Plug 'haya14busa/incsearch.vim'
Plug 'haya14busa/incsearch-easymotion.vim'
Plug 'haya14busa/incsearch-easymotion.vim'
Plug 'haya14busa/incsearch-fuzzy.vim'
Plug 'haya14busa/vim-operator-flashy'
Plug 'jeetsukumaran/vim-indentwise'

"" others
Plug 'Shougo/vimproc.vim'
Plug 'lervag/vimtex'
Plug 'dyng/ctrlsf.vim', { 'on': [] }
Plug 'vim-scripts/YankRing.vim', { 'on': [] }
Plug 'mattn/emmet-vim'
Plug 'tpope/vim-repeat'
Plug 'plasticboy/vim-markdown'
Plug 'kana/vim-operator-user'

Plug 'tiagofumo/vim-nerdtree-syntax-highlight'
Plug 'christoomey/vim-tmux-navigator'
Plug 'tpope/vim-dispatch'
call plug#end()

if has('nvim')
    let s:editor_root=expand("~/.nvim")
else
    let s:editor_root=expand("~/.vim")
endif

" --- AutoClose - Inserts matching bracket, paren, brace or quote 
" fixed the arrow key problems caused by AutoClose
if !has("gui_running")  
"   "set term=linux
"   imap OA <ESC>ki
"   imap OB <ESC>ji
"   imap OC <ESC>li
"   imap OD <ESC>hi
    nmap OA k
    nmap OB j
    nmap OC l
    nmap OD h
    "for tmux wired character
    map <Esc>[B <Down>
endif

filetype plugin indent on
" General SETTINGS 
set hidden
set nocompatible    " not compatible with the old-fashion vi mode
set bs=2        " allow backspacing over everything in insert mode
set history=50      " keep 50 lines of command line history
set ruler       " show the cursor position all the time
set autoread        " auto read when file is changed from outside
setlocal textwidth=80
set number
"set relativenumber
set list lcs=tab:\|\ 
autocmd FileType c,cpp call MyCodeStyle()

function! MyCodeStyle()
  "highlight CodeFormatError ctermbg=red ctermfg=white guibg=#592929
  syn match CodeFormatError / \+\ze\t/     " spaces before tab
  syn match CodeFormatError /\%81v.\+/     " virtual column 81 and more
  highlight default link CodeFormatError ErrorMsg
  "match CodeFormatError / \+\ze\t/          "spaces before tab
  " Highlight trailing whitespace, unless we're in insert mode and the
  " cursor's placed right after the whitespace. This prevents us from having
  " to put up with whitespace being highlighted in the middle of typing
  " something
  autocmd InsertEnter * match CodeFormatError /\s\+\%#\@<!$/
  autocmd InsertLeave * match CodeFormatError /\s\+$/
endfunction

filetype off          " necessary to make ftdetect work on Linux
syntax on
filetype on           " Enable filetype detection
filetype indent on    " Enable filetype-specific indenting
filetype plugin on    " Enable filetype-specific plugins

" auto reload vimrc when editing it
autocmd! bufwritepost .vimrc source ~/.vimrc

if has("gui_running")   " GUI color and font settings
  set autochdir
  "set guifont=Osaka-Mono:h20
  "set guifont=pika:h20
  set guifont =Droid\ Sans\ Mono\ for\ Powerline:h20
  "set guifont =Droid\ Sans\ Mono\ for\ Powerline\ Nerd\ Font\ Complete
  set background=dark 
  set t_Co=256          " 256 color mode
  set cursorline        " highlight current line
  colors solarized
  set background=dark
  highlight CursorLine          guibg=#003853 ctermbg=24  gui=none cterm=none
else
  highlight CursorLine          guibg=#003853 ctermbg=24  gui=none cterm=none
  set cursorline
" terminal color settings
  set t_Co=256          " 256 color mode
  let g:solarized_termcolors = &t_Co
  let g:solarized_termtrans = 0
  let g:solarized_degrade = 0
  let g:solarized_italic=0
  let g:solarized_contrast = "nomal"
  let g:solarized_visibility= "normal"
  "terminal setting
  "set t_AB=^[[48;5;%dm
  "set t_AF=^[[38;5;%dm
  "color solarized 
  "set background=dark
  color solarized   "workaround for nvim, this cause nvim war color use now
  set hlsearch      " search highlighting
endif

""" Customize colors

autocmd FileType c,cpp hi Pmenu ctermfg=7 ctermbg=236
autocmd FileType c,cpp hi PmenuSel ctermfg=white ctermbg=32
autocmd FileType c,cpp hi CocFloating ctermfg=black ctermbg=240

"spell check on
function! s:spell_on()
    set spell spelllang=en_us
endfunction
command! SpellOn call s:spell_on()
nnoremap <C-C> z=


"folding settings
set foldmethod=indent   "fold based on indent
set foldnestmax=10      "deepest fold is 10 levels
set nofoldenable        "donnt fold by default
set foldlevel=1         "this is just what i use

function! ChangeFold()
    if &foldmethod == 'syntax'
        set foldmethod=indent 
    else
        set foldmethod=syntax 
    endif
endfunction
nnoremap  fd :call ChangeFold()<CR> 

set updatetime=100
set clipboard=unnamed,unnamedplus " yank to the system register (*) by default
set showmatch       " Cursor shows matching ) and }
set showmode        " Show current mode
set wildchar=<TAB>  " start wild expansion in the command line using <TAB>
set wildmenu            " wild char completion menu

" ignore ]f ese files while expanding wild chars
set wildignore=*.o,*.class,*.pyc

set autoindent      " auto indentation
set incsearch       " incremental search
set nobackup        " no *~ backup files
set copyindent      " copy the previous indentation on autoindenting
set ignorecase      " ignore case when searching
set smartcase       " ignore case if search pattern is all lowercase,case-sensitive otherwise
set smarttab        " insert tabs on the start of a line according to context

" disable sound on errors
set noerrorbells
set novisualbell
set t_vb=
set tm=500

" TAB setting{
   set expandtab        "replace <TAB> with spaces
   set tabstop=4           " number of spaces a tab counts for
   set shiftwidth=4        " spaces for autoindents
   au FileType Makefile set noexpandtab
"}                                  

" status line {
set laststatus=2
set statusline=\ %{HasPaste()}%<%-15.25(%f%)%m%r%h\ %w\ \ 
set statusline+=\ \ \ [%{&ff}/%Y] 
set statusline+=\ \ \ %<%20.30(%{hostname()}:%{CurDir()}%)\ 
set statusline+=%=%-10.(%l,%c%V%)\ %p%%/%L
set fillchars+=stl:\ ,stlnc:\


function! CurDir()
    let curdir = substitute(getcwd(), $HOME, "~", "")
    return curdir
endfunction

function! HasPaste()
    if &paste
        return '[PASTE]'
    else
        return ''
    endif
endfunction

"}


" C/C++ specific settings
autocmd FileType c,cpp,cc  set cindent comments=sr:/*,mb:*,el:*/,:// cino=>s,e0,n0,f0,{0,}0,^-1s,:0,=s,g0,h1s,p2,t0,+2,(2,)20,*30

" Automatically open, but do not go to (if there are errors) the quickfix /
" location list window, or close it when is has become empty.
"
" Note: Must allow nesting of autocmds to enable any customizations for quickfix
" buffers.
" Note: Normally, :cwindow jumps to the quickfix window if the command opens it
" (but not if it's already open). However, as part of the autocmd, this doesn't
" seem to happen.
autocmd QuickFixCmdPost [^l]* nested cwindow
autocmd QuickFixCmdPost    l* nested lwindow
"autocmd FileType c,cpp,cc set shellpipe=1>


"--------------------------------------------------------------------------- 
" USEFUL SHORTCUTS
"--------------------------------------------------------------------------- 
" set leader to ,
let mapleader=","
let g:mapleader=","

"--------------------------------------------------------------------------- 
" Tip #382: Search for <cword> and replace with input() in all open buffers 
"--------------------------------------------------------------------------- 
fun! Replace() 
    let s:word = input("Replace " . expand('<cword>') . " with:") 
    :exe 'bufdo! %s/\<' . expand('<cword>') . '\>/' . s:word . '/ge' 
    :unlet! s:word 
endfun 

"--------------------------------------------------------------------------- 
" insert ; after )
"--------------------------------------------------------------------------- 
function! <SID>InsSemiColon() abort
    let l:line = line('.')
    let l:content = getline('.')
    let l:eol = ';'
    " If the line ends with a semicolon we simply insert one.
    if l:content[col('$') - 2] ==# ';'
        normal! a;
        normal! l
        startinsert
    else
        if search('(', 'bcn', l:line)
            let l:eol = search(')', 'cn', l:line) ?  ';' : ');'
        endif
        call setline(l:line, l:content . l:eol)
        startinsert!
    endif
endfunction

"Twiddle Case
"press ~ to convert the text to  UPPER CASE, then to lower case, then to Title Case
function! TwiddleCase(str)
  if a:str ==# toupper(a:str)
    let result = tolower(a:str)
  elseif a:str ==# tolower(a:str)
    let result = substitute(a:str,'\(\<\w\+\>\)', '\u\1', 'g')
  else
    let result = toupper(a:str)
  endif
  return result
endfunction
vnoremap ~ y:call setreg('', TwiddleCase(@"), getregtype(''))<CR>gv""Pgv

" If the current buffer has never been saved, it will have no name,
" call the file browser to save it, otherwise just save it.
command! -nargs=0 -bar Update if &modified 
                           \|    if empty(bufname('%'))
                           \|        browse confirm write
                           \|    else
                           \|        confirm write
                           \|    endif
                           \|endif
nnoremap <silent> <C-S> :<C-u>Update<CR>

"Insert semicolon
inoremap <silent> ; <Esc>:call <SID>InsSemiColon()<CR>

"replace the current word in all opened buffers
map <leader>rw :call Replace()<CR>

"map esc key
inoremap jk <ESC>
vnoremap jk <ESC>

"movement in insert mode
inoremap <C-w> <S-RIGHT>
inoremap <C-b> <S-LEFT>

" open the error console
map <leader>co :botright cope<CR>
map <leader>cx :cclose<CR>
" move to next error
map ]e :cn<CR>
" move to the prev error
map [e :cp<CR>

" --- move around splits {
"decrease window
map <leader><leader>l <C-W><
"increase window
map <leader><leader>h <C-W>>
"decrease window
map <leader><leader>j <C-W>-
"increase window
map <leader><leader>k <C-W>+
" move to and maximize the below split 
"map <C-j> <C-w>j<C-w>_
" move to and maximize the above split 
"map <C-k> <C-w>k<C-w>_
" move to and maximize the left split 
"nmap <C-h> <c-w>h<c-w><bar>
" move to and maximize the right split  
"nmap <C-l> <c-w>l<c-w><bar>
set wmw=0                     " set the min width of a window to 0 so we can maximize others 
set wmh=0                     " set the min height of a window to 0 so we can maximize others
" }

" move around tabs. conflict with the original screen top/bottom
" comment them out if you want the original H/L
" go to prev tab 
"map <S-H> gT
" go to next tab
"map <S-L> gt

" new tab
map <C-t><C-t> :tabnew<CR>
" close tab
map <C-t><C-w> :tabclose<CR> 

" ,/ turn off search highlighting
nmap <leader>/ :nohl<CR>

" Bash like keys for the command line
cnoremap <C-A>      <Home>
cnoremap <C-E>      <End>
"cnoremap <C-K>      <C-U>
cnoremap <C-k>      <Up>
cnoremap <C-j>      <Down>
cnoremap <C-h>      <Left>
cnoremap <C-l>      <Right>

" ,p toggles paste mode
nmap <leader>p :set paste!<BAR>set paste?<CR>

" allow multiple indentation/deindentation in visual mode
vnoremap < <gv
vnoremap > >gv

" :cd. change working directory to that of the current file
cmap cd. lcd %:p:h

" Writing Restructured Text (Sphinx Documentation) {
   " Ctrl-u 1:    underline Parts w/ #'s
   " noremap  <C-u>1 yyPVr#yyjp
   " inoremap <C-u>1 <esc>yyPVr#yyjpA
   " " Ctrl-u 2:    underline Chapters w/ *'s
   " noremap  <C-u>2 yyPVr*yyjp
   " inoremap <C-u>2 <esc>yyPVr*yyjpA
   " " Ctrl-u 3:    underline Section Level 1 w/ ='s
   " noremap  <C-u>3 yypVr=
   " inoremap <C-u>3 <esc>yypVr=A
   " " Ctrl-u 4:    underline Section Level 2 w/ -'s
   " noremap  <C-u>4 yypVr-
   " inoremap <C-u>4 <esc>yypVr-A
   " " Ctrl-u 5:    underline Section Level 3 w/ ^'s
   " noremap  <C-u>5 yypVr^
   " inoremap <C-u>5 <esc>yypVr^A
"}

"--------------------------------------------------------------------------- 
" PROGRAMMING SHORTCUTS
"--------------------------------------------------------------------------- 
"split line
nnoremap K i<CR><Esc>
nnoremap <F8> :Make build -Prtsp=true -Pnet=true -Pconf_files=AU3518P_WIFI.h,AU3522_COM.h,CONFIG_CHK.h<CR>

" Ctrl-[ jump out of the tag stack (undo Ctrl-])
map <C-[> <ESC>:po<CR>

" ,g generates the header guard
map <leader>g :call IncludeGuard()<CR>
fun! IncludeGuard()
   let basename = substitute(bufname(""), '.*/', '', '')
   let guard = '_' . substitute(toupper(basename), '\.', '_', "H")
   call append(0, "#ifndef " . guard)
   call append(1, "#define " . guard)
   call append( line("$"), "#endif // for #ifndef " . guard)
endfun



" Enable omni completion. (Ctrl-X Ctrl-O)
"autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
"autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
"autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
"autocmd FileType css set omnifunc=csscomplete#CompleteCSS
"autocmd FileType c set omnifunc=ccomplete#Complete
"autocmd FileType java set omnifunc=javacomplete#Complete


set cot-=preview "disable doc preview in omnicomplete

" make CSS omnicompletion work for SASS and SCSS
autocmd BufNewFile,BufRead *.scss             set ft=scss.css
autocmd BufNewFile,BufRead *.sass             set ft=sass.css

"--------------------------------------------------------------------------- 
" ENCODING SETTINGS
"--------------------------------------------------------------------------- 
"set encoding=utf-8                                
set termencoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,big5,gb2312,latin1
"ucs-bom

fun! ViewUTF8()
    set encoding=utf-8                                  
    set termencoding=big5
endfun

fun! UTF8()
    set encoding=utf-8                                  
    set termencoding=big5
    set fileencoding=utf-8
    set fileencodings=ucs-bom,big5,utf-8,latin1
endfun

fun! Big5()
    set encoding=big5
    set fileencoding=big5
endfun

"--------------------------------------------------------------------------- 
" PLUGIN SETTINGS
"--------------------------------------------------------------------------- 

" ---yankring
nnoremap <Leader>yr :YRShow<Cr>
"for windows platorms, you must change yankring replace key <C-P> and <C-N>
"let g:yankring_replace_n_nkey = '<c-r>'

"vim-indent-guides
"let g:indent_guides_auto_colors = 1
"autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=3
"autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=4
"let g:indent_guides_enable_on_vim_startup = 1 
"let g:indent_guides_color_change_percent = 7
"let g:indent_guides_guide_size            = 0
"let g:indent_guides_start_level      = 2

" ---------------------------------------------------------------------------
" EasyMotion
" --------------------------------------------------------------------------- 
let g:EasyMotion_leader_key = '\' " default is <Leader>w
hi link EasyMotionTarget ErrorMsg
hi link EasyMotionShade  Comment
let g:EasyMotion_use_upper = 1
 " type `l` and match `l`&`L`
let g:EasyMotion_smartcase = 1
 " " Smartsign (type `3` and match `3`&`#`)
let g:EasyMotion_use_smartsign_us = 1"
map <leader>l <Plug>(easymotion-lineforward)
map <leader>j <Plug>(easymotion-j)
map <leader>k <Plug>(easymotion-k)
map <leader>h <Plug>(easymotion-linebackward)
" Gif config
"nmap <leader>s <Plug>(easymotion-s2)
"nmap <leader>t <Plug>(easymotion-t2)

"without incsearch
"map  / <Plug>(easymotion-sn)
"omap / <Plug>(easymotion-tn)

noremap <silent><expr> /  incsearch#go(<SID>incsearch_config())

map  ww <Plug>(easymotion-bd-w)
omap  tt <Plug>(easymotion-bd-tl)
" These `n` & `N` mappings are options. You do not have to map `n` & `N` to EasyMotion.
" Without these mappings, `n` & `N` works fine. (These mappings just provide
" different highlight method and have some other features )
map  <leader>n <Plug>(easymotion-next)
map  <leader>N <Plug>(easymotion-prev)
"smartcase(lazy search)
let g:EasyMotion_smartcase = 1

" You can use other keymappings like <C-l> instead of <CR> if you want to
" use these mappings as default search and somtimes want to move cursor with
" EasyMotion.
function! s:incsearch_config_fuzzy(...) abort
  return incsearch#util#deepextend(deepcopy({
  \   'converters': [incsearch#config#fuzzy#converter()],
  \   'modules': [incsearch#config#easymotion#module()],
  \   'keymap': {
  \     "\<CR>": '<Over>(easymotion)'
  \   },
  \   'is_expr': 0,
  \   'is_stay': 0
  \ }), get(a:, 1, {}))
endfunction

function! s:incsearch_config(...) abort
  return incsearch#util#deepextend(deepcopy({
  \   'modules': [incsearch#config#easymotion#module()],
  \   'keymap': {
  \     "\<CR>": '<Over>(easymotion)'
  \   },
  \   'is_expr': 0
  \ }), get(a:, 1, {}))
endfunction

noremap <silent><expr> z/  incsearch#go(<SID>incsearch_config())
noremap <silent><expr> z?  incsearch#go(<SID>incsearch_config({'command': '?'}))
noremap <silent><expr> zg/ incsearch#go(<SID>incsearch_config({'is_stay': 1}))
noremap <silent><expr> f/  incsearch#go(<SID>incsearch_config_fuzzy())
noremap <silent><expr> f?  incsearch#go(<SID>incsearch_config_fuzzy({'command': '?'}))
noremap <silent><expr> fg/ incsearch#go(<SID>incsearch_config_fuzzy({'is_stay': 1}))

" --- TagBar
" toggle TagBar with F7
nnoremap <silent> <leader>t :TagbarToggle<CR> 
" set focus to TagBar when opening it
"let g:tagbar_autofocus = 1
let g:tagbar_width=25

"map ctrl-space to trigger autocomplete under terminal
if !has("gui_running")
    inoremap <C-@> <C-x><C-o>
else
    inoremap <C-Space> <C-x><C-o>
endif

"UltiSnips
" Trigger configuration. Do not use <tab> if you use https://github.com/Vallor"ic/YouCompleteMe.
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsSnippetDirectories=["UltiSnips"]

"auto-pairs
let g:AutoPairs = {'<' : '>' ,'(' : ')', '[' : ']', '{' : '}', "'" : "'", '"' : '"', '`' : '`'}

"fswitch
au BufEnter *.cpp let b:fswitchdst = 'hpp,h' | let b:fswitchlocs = './,./include,../include'
au BufEnter *.c let b:fswitchdst = 'h,hh' | let b:fswitchlocs = './,./include,../include'
au BufEnter *.hh let b:fswitchdst = 'c,cpp' | let b:fswitchlocs = '../,./,../src'
au BufEnter *.h let b:fswitchdst = 'cpp,c' | let b:fswitchlocs = './,../,../src'
nmap <silent> <Leader>of :FSHere<cr>

"nerdtree
let g:NERDTreeWinSize=20
let NERDTreeIgnore=['\~$', '\.pyc', '\.swp$', '\.git', '\.hg', '\.svn',
\ '\.ropeproject', '\.o', '\.bzr', '\.ipynb_checkpoints$',
\ '__pycache__',
\ '\.egg$', '\.egg-info$', '\.tox$', '\.idea$', '\.sass-cache',
\ '\.env$', '\.env[0-9]$', '\.coverage$', '\.tmp$', '\.gitkeep$',
\ '\.coverage$', '\.webassets-cache$', '\.vagrant$', '\.DS_Store',
\ '\.env-pypy$', 'tags', '\.a$', 'GPATH', 'GRTAGS', 'GTAGS', 'gtags.files']

"nerdtree tab
nnoremap <leader>nd :NERDTreeTabsToggle<CR>
let g:nerdtree_tabs_open_on_gui_startup=0

"support markdown hightlight
au BufRead,BufNewFile *.{md,mdown,mkd,mkdn,markdown,mdwn}   set filetype=mkd

"multiple cursor
" Map start key separately from next key
let g:multi_cursor_start_key='<leader>c'
let g:multi_cursor_start_word_key='<leader>cw'

"doxgen toolkit
let g:DoxygenToolkit_interCommentTag = ""
let g:DoxygenToolkit_interCommentBlock = ""
let g:DoxygenToolkit_endCommentTag = " */"
let g:DoxygenToolkit_endCommentBlock = "*/"
"let g:DoxygenToolkit_briefTag_pre=""
let g:DoxygenToolkit_briefTag_funcName = "yes"
let g:DoxygenToolkit_briefTag_post = " - "
let g:DoxygenToolkit_paramTag_pre="@Param "
let g:DoxygenToolkit_paramTag_post=" : "
let g:DoxygenToolkit_returnTag="@Returns   "
"let g:DoxygenToolkit_blockHeader="--------------------------------------------------------------------------"
"let g:DoxygenToolkit_blockFooter="----------------------------------------------------------------------------"
let g:DoxygenToolkit_authorName="Pika Jian"
"let g:DoxygenToolkit_licenseTag="My own license"   <-- !!! Does not end with "\<enter>"

"surround vim
"- key
let b:surround_105 = "(\r)"
map <leader>gs      gSi

"easy align
" Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
vmap <Enter> <Plug>(EasyAlign)
" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

"airline
"
let g:airline#extensions#disable_rtp_load = 1
let g:airline_extensions = ['branch', 'tabline']
let g:airline_powerline_fonts = 1
let g:airline_theme="solarized" 
let g:airline#extensions#whitespace#enabled = 0
"let g:airline_section_y = airline#section#create(['','[TYPE:','filetype',']','[TIME:','%{strftime("%H:%M")}',']'])
"let g:airline_section_z = airline#section#create(['%3p%% ', g:airline_symbols.linenr .' ', 'linenr', ':%3c '])
"git branch info 
let g:airline#extensions#branch#enabled = 1

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_close_button = 1
let g:airline#extensions#tabline#show_tab_type = 0
let g:airline#extensions#tabline#buffer_idx_mode = 1
let g:airline#extensions#tabline#middle_click_preserves_windows = 0
" Show just the filename
let g:airline#extensions#tabline#fnamemod = ':t'
" show buffer number
let g:airline#extensions#tabline#buffer_nr_show = 0
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#show_splits = 1
let g:airline#extensions#tabline#show_tabs = 1
let g:airline#extensions#tabline#excludes = ['[0-9]\+:zsh$']
nmap <leader>1 <Plug>AirlineSelectTab1
nmap <leader>2 <Plug>AirlineSelectTab2
nmap <leader>3 <Plug>AirlineSelectTab3
nmap <leader>4 <Plug>AirlineSelectTab4
nmap <leader>5 <Plug>AirlineSelectTab5
nmap <leader>6 <Plug>AirlineSelectTab6
nmap <leader>7 <Plug>AirlineSelectTab7
nmap <leader>8 <Plug>AirlineSelectTab8
nmap <leader>9 <Plug>AirlineSelectTab9
nmap <leader>- <Plug>AirlineSelectPrevTab
nmap <leader>= <Plug>AirlineSelectNextTab

"buffer operation for tabline
nmap <leader>T :enew<cr>
nmap <leader>bd :bp <BAR> bd! #<cr>

"buffer map
" Move to the next buffer
nmap <S-l> :bnext<CR>
" Move to the previous buffer
nmap <S-h> :bprevious<CR>

"ctrlspace
let g:CtrlSpaceDefaultMappingKey = "<C-Space>"
"silver searcher (Ag)
let g:ag_prg="ag --column --ignore tags"


augroup qf
  autocmd!
  autocmd FileType qf set nobuflisted
augroup END

let g:linuxsty_patterns = [ "/linux/", "/linux-2.6/"]

"fugitive
autocmd User fugitive 
  \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)$' |
  \   nnoremap <buffer> .. :edit %:h<CR> |
  \ endif
autocmd BufReadPost fugitive://* set bufhidden=hide

"nerdCommenter
let g:NERDSpaceDelims=0
" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1
let g:NERDCustomDelimiters = { 'c': { 'left': '//', 'leftAlt': '/* ', 'rightAlt': ' */' } }
map gcc <plug>NERDCommenterComment

map gcs <plug>NERDCommenterSexy
map gcA <plug>NERDCommenterAppend
map gcy <plug>NERDCommenterYank
map gca <plug>NERDCommenterAltDelims
map gcl <plug>NERDCommenterAlignLeft
map gcb <plug>NERDCommenterAlignBoth
map gcm <plug>NERDCommenterMinimal
map gcu <plug>NERDCommenterUncomment
 
"Gtags
set cscopeprg=gtags-cscope

let Gtags_Close_When_Single = 1
let Gtags_Auto_Update = 0
let g:cscope_silent = 1
"au FileType php,pyhthon,c,cpp,javascrip,go map <C-]> :Gtags<CR><CR>
"au FileType php,python,c,cpp,javascript,go map <C-[> :Gtags -r<CR><CR>

"CtrlP
" Use The Silver Searcher https://github.com/ggreer/the_silver_searcher
if executable('ag')
  " Use Ag over Grep
  set grepprg=ag\ --nogroup\ --nocolor

  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'

  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
endif

let g:ctrlp_match_window = 'bottom,order:btt,min:1,max:10,results:200'

"set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*/.tmp/*,*/.sass-cache/*,*/node_modules/*,*.keep,*.DS_Store,*/.git/*
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\v[\/]\.(git|hg|svn)$',
  \ 'file': '\v\.(exe|so|dll)$',
  \ 'link': 'some_bad_symbolic_links',
  \ }

let g:ctrlp_map = '<C-p>'
let g:ctrlp_cmd = 'CtrlPBuffer'
let g:ctrlp_user_command = 'find %s -type f'
let g:ctrlp_types = ['buf', 'mru']
let g:ctrlp_prompt_mappings = {
  \ 'PrtBS()':              ['<bs>', '<c-]>'],
  \ 'PrtDelete()':          ['<del>'],
  \ 'PrtDeleteWord()':      ['<c-w>'],
  \ 'PrtClear()':           ['<c-u>'],
  \ 'PrtSelectMove("j")':   ['<c-j>', '<down>'],
  \ 'PrtSelectMove("k")':   ['<c-k>', '<up>'],
  \ 'PrtSelectMove("t")':   ['<Home>', '<kHome>'],
  \ 'PrtSelectMove("b")':   ['<End>', '<kEnd>'],
  \ 'PrtSelectMove("u")':   ['<PageUp>', '<kPageUp>'],
  \ 'PrtSelectMove("d")':   ['<PageDown>', '<kPageDown>'],
  \ 'PrtHistory(-1)':       ['<c-n>'],
  \ 'PrtHistory(1)':        ['<c-p>'],
  \ 'AcceptSelection("e")': ['<cr>'],
  \ 'AcceptSelection("h")': ['<c-x>', '<c-cr>', '<c-s>'],
  \ 'AcceptSelection("t")': ['<c-t>', '<2-LeftMouse>'],
  \ 'AcceptSelection("v")': ['<c-v>', '<RightMouse>'],
  \ 'ToggleFocus()':        ['<s-tab>'],
  \ 'ToggleRegex()':        ['<c-r>'],
  \ 'ToggleByFname()':      ['<c-d>'],
  \ 'ToggleType(1)':        ['<c-f>', '<c-up>'],
  \ 'ToggleType(-1)':       ['<c-b>', '<c-down>'],
  \ 'PrtExpandDir()':       ['<tab>'],
  \ 'PrtInsert("c")':       ['<MiddleMouse>', '<insert>'],
  \ 'PrtInsert()':          ['<c-\>'],
  \ 'PrtCurStart()':        ['<c-a>'],
  \ 'PrtCurEnd()':          ['<c-e>'],
  \ 'PrtCurLeft()':         ['<c-h>', '<left>', '<c-^>'],
  \ 'PrtCurRight()':        ['<c-l>', '<right>'],
  \ 'PrtClearCache()':      ['<F5>'],
  \ 'PrtDeleteEnt()':       ['<F7>'],
  \ 'CreateNewFile()':      ['<c-y>'],
  \ 'MarkToOpen()':         ['<c-z>'],
  \ 'OpenMulti()':          ['<c-o>'],
  \ 'PrtExit()':            ['<esc>', '<c-c>', '<c-g>'],
  \ }
" ctrlp-funky
let g:ctrlp_funky_syntax_highlight = 1
nnoremap <Leader>fu :CtrlPFunky<Cr>
" narrow the list down with a word under cursor
nnoremap <Leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<Cr>
let g:ctrlp_funky_syntax_highlight = 1
let g:ctrlp_extensions = ['funky']

"indent guide line
let g:indent_guides_guide_size = 1

"devicons
let g:WebDevIconsUnicodeDecorateFolderNodes = 1
let g:DevIconsEnableFoldersOpenClose = 1
let g:webdevicons_enable_ctrlp = 1
" adding to vim-airline's tabline 
let g:webdevicons_enable_airline_tabline = 0

"clang-format for formating cpp code
" //格式化最新的commit，并直接在原文件上修改
" git diff -U0 HEAD^ | clang-format-diff.py -i -p1
nnoremap <leader>lf :call FormatCode("LLVM")<CR>
vnoremap <leader>lf :call FormatCode("LLVM")<CR>
vnoremap <leader>cf :call FormatCode("Chromium")<CR>
nnoremap <leader>cf :call FormatCode("Chromium")<CR>
nnoremap <leader>gf :call FormatCode("Google")<CR>
vnoremap <leader>gf :call FormatCode("Google")<CR>
"let g:autoformat_verbosemode = 1
let g:autoformat_autoindent = 1

func! FormatCode(style)
  let firstline=line(".")
  let lastline=line(".")
  " Visual mode
  if exists(a:firstline)
    firstline = a:firstline
    lastline = a:lastline
  endif
  let g:formatdef_clangformat = "'clang-format-3.8
                          \ --lines='.a:firstline.':'.a:lastline.'        
                          \ --assume-filename='.bufname('%').'            
                          \ -style=" . a:style . "'"
  let formatcommand = ":" . firstline . "," . lastline . "Autoformat"
  exec formatcommand
endfunc

"command -nargs=1 PikaFormatCode :call FormatCode(<f-args>)

"rename tmux tab window name to open filename 
"check tmux installed
if executable('tmux')
  autocmd BufReadPost,FileReadPost,BufNewFile * call system('tmux rename-window '.expand("%:h"))
endif
"tmux navigator
"let g:loaded_tmux_navigator = 1
"let g:tmux_navigator_no_mappings = 1

"command! -bar -nargs=+ -complete=customlist,functions#GitBugComplete Gbug Git bug <q-args>
"command! -bar -nargs=+ -complete=customlist,functions#GitFeatureComplete Gfeature Git feature <q-args>
"command! -bar -nargs=+ -complete=customlist,functions#GitRefactorComplete Grefactor Git refactor <q-args>

"vim-sneak
let g:sneak#label = 1

"vim-ack
if executable('ag')
  let g:ackprg = 'ag --vimgrep'
endif

"vim-startify
let g:startify_enable_special         = 0
let g:startify_files_number           = 8
let g:startify_relative_path          = 1
let g:startify_change_to_dir          = 1
let g:startify_update_oldfiles        = 1
let g:startify_session_autoload       = 1
let g:startify_session_persistence    = 1

let g:startify_skiplist = [
        \ 'COMMIT_EDITMSG',
        \ 'bundle/.*/doc',
        \ '/data/repo/neovim/runtime/doc',
        \ '/Users/mhi/local/vim/share/vim/vim74/doc',
        \ ]

let g:startify_bookmarks = [
        \ { 'c': '~/.vim/vimrc' },
        \ '~/golfing',
        \ ]

let g:startify_custom_header =
        \ startify#fortune#cowsay('═','║','╔','╗','╝','╚')

let g:startify_custom_footer =
       \ ['', "   Vim is charityware. Please read ':help uganda'.", '']

hi StartifyBracket ctermfg=240
hi StartifyFile    ctermfg=147
hi StartifyFooter  ctermfg=240
hi StartifyHeader  ctermfg=114
hi StartifyNumber  ctermfg=215
hi StartifyPath    ctermfg=245
hi StartifySlash   ctermfg=240
hi StartifySpecial ctermfg=240
let g:startify_enable_special         = 0
let g:startify_files_number           = 8
let g:startify_relative_path          = 1
let g:startify_change_to_dir          = 1
let g:startify_update_oldfiles        = 1
let g:startify_session_autoload       = 1
let g:startify_session_persistence    = 1

let g:startify_skiplist = [
        \ 'COMMIT_EDITMSG',
        \ 'bundle/.*/doc',
        \ '/data/repo/neovim/runtime/doc',
        \ '/Users/mhi/local/vim/share/vim/vim74/doc',
        \ ]

let g:startify_bookmarks = [
        \ { 'c': '~/.vim/vimrc' },
        \ '~/golfing',
        \ ]

let g:startify_custom_header =
        \ startify#fortune#cowsay('═','║','╔','╗','╝','╚')

let g:startify_custom_footer =
       \ ['', "   Vim is charityware. Please read ':help uganda'.", '']

hi StartifyBracket ctermfg=240
hi StartifyFile    ctermfg=147
hi StartifyFooter  ctermfg=240
hi StartifyHeader  ctermfg=114
hi StartifyNumber  ctermfg=215
hi StartifyPath    ctermfg=245
hi StartifySlash   ctermfg=240
hi StartifySpecial ctermfg=240

"FZF
autocmd FileType qf wincmd J
nnoremap <leader><Enter> :FZF<CR>

if has('nvim')
tnoremap jk <C-c>   
endif

" Augmenting Rg command using fzf#vim#with_preview function
"   * fzf#vim#with_preview([[options], preview window, [toggle keys...]])
"   * Preview script requires Ruby
"   * Install Highlight or CodeRay to enable syntax highlighting
"
"   :Ag  - Start fzf with hidden preview window that can be enabled with "?" key
"   :Ag! - Start fzf in fullscreen and display the preview window above
command! -bang -nargs=* -complete=file Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --no-heading --color=always '.
  \   shellescape(<q-args>)[1:strlen(shellescape(<q-args>)) - 2],
  \   1,
  \   <bang>0 ? fzf#vim#with_preview('up:60%')
  \           : fzf#vim#with_preview('right:50%:hidden', '?'),
  \   <bang>0)

" Augmenting Ag command using fzf#vim#with_preview function
"   * fzf#vim#with_preview([[options], preview window, [toggle keys...]])
"     * For syntax-highlighting, Ruby and any of the following tools are required:
"       - Highlight: http://www.andre-simon.de/doku/highlight/en/highlight.php
"       - CodeRay: http://coderay.rubychan.de/
"       - Rouge: https://github.com/jneen/rouge
"
"   :Ag  - Start fzf with hidden preview window that can be enabled with "?" key
"   :Ag! - Start fzf in fullscreen and display the preview window above
command! -bang -nargs=* Ag
  \ call fzf#vim#ag(<q-args>,
  \                 <bang>0 ? fzf#vim#with_preview('up:60%')
  \                         : fzf#vim#with_preview('right:50%:hidden', '?'),
  \                 <bang>0)

command! -bang -nargs=? -complete=dir Files
  \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)

command! FZFMru call fzf#run({
\ 'source':  reverse(s:all_files()),
\ 'sink':    'edit',
\ 'options': '-m -x +s',
\ 'down':    '40%' })

function! s:all_files()
  return extend(
  \ filter(copy(v:oldfiles),
  \        "v:val !~ 'fugitive:\\|NERD_tree\\|^/tmp/\\|.git/|term:\\\\'"),
  \ map(filter(range(1, bufnr('$')), 'buflisted(v:val)'), 'bufname(v:val)'))
endfunction

nnoremap <leader>f :Files<CR>
nnoremap <leader>w :FZFMru<CR>
nnoremap <leader>y :History<CR>
nnoremap <leader>e :Buffers<CR>
nnoremap <leader>l :BLine<CR>
"nnoremap <leader>t :Tags<CR>
nnoremap bt :BTags<CR>
nnoremap <leader>s :Rg <C-r><C-w><CR>
nnoremap bs :vimgrep <C-r><C-w> %<CR>

" Replace the default dictionary completion with fzf-based fuzzy completion
"inoremap <expr> <c-x><c-k> fzf#complete('cat /usr/share/dict/words')
" Mapping selecting mappings
nmap <leader><tab> <plug>(fzf-maps-n)
xmap <leader><tab> <plug>(fzf-maps-x)
omap <leader><tab> <plug>(fzf-maps-o)
" Insert mode completion
imap <c-x><c-k> <plug>(fzf-complete-word)
imap <c-x><c-f> <plug>(fzf-complete-path)
imap <c-x><c-j> <plug>(fzf-complete-file-ag)
imap <c-x><c-l> <plug>(fzf-complete-line)
imap <c-x><c-b> <plug>(fzf-complete-buffer-line)

"coc.vim {{{

" Use `[c` and `]c` for navigate diagnostics
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" Remap keys for gotos
nmap <silent> <leader>jd <Plug>(coc-definition)
nmap <silent> <leader>jy <Plug>(coc-type-definition)
nmap <silent> <leader>ji <Plug>(coc-implementation)
nmap <silent> <leader>jr <Plug>(coc-references)
nmap <silent> <leader>gr :call <SID>test_reference_list()<CR>

function! s:format_qf_refs(item) abort
  return {'filename' : a:item['filepath'], 'lnum' : a:item['lnum'], 'col': a:item['col'], 'text' : a:item['text']}
endfunction

function! s:test_reference_list()
  let l:loc = CocAction('referenceList')
  "echo loc
  if !empty(l:loc)
      call setqflist(map(l:loc, 's:format_qf_refs(v:val)'), 'r', "References")
      copen
  endif
endfunction

" Use K for show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if &filetype == 'vim'
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use tab for trigger completion with characters ahead and navigate.
" NOTE: There's always complete item selected by default, you may want to enable
" no select by `"suggest.noselect": true` in your configuration file.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
" other pl
inoremap <silent><expr> <c-j>
     \ coc#pum#visible() ? coc#pum#next(1) :
      \ CheckBackspace() ? "\<Tab>" :
      \ coc#refresh()

inoremap <expr><c-k> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"






" Make <CR> to accept selected completion item or notify coc.nvim to format
" <C-g>u breaks current undo, please make your own choice.
inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"


"inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm() : "\<C-y>"

" Remap <C-f> and <C-b> for scroll float windows/popups.
if has('nvim-0.4.0') || has('patch-8.2.0750')
  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
endif

"old coc
"inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
"inoremap <expr> <C-j> coc#pum#visible() ? "\<C-n>" : "\<C-j>"
"inoremap <expr> <C-k> coc#pum#visible() ? "\<C-p>" : "\<C-k>"

"}}}
"

let g:LanguageClient_loadSettings = 1 " Use an absolute configuration path if you want system-wide settings
let g:LanguageClient_settingsPath = '~/.config/nvim/neovim-lsp-settings.json'
" https://github.com/autozimu/LanguageClient-neovim/issues/379 LSP snippet is not supported
let g:LanguageClient_hasSnippetSupport = 1
let g:LanguageClient_loggingFile = expand('/tmp/LanguageClient.log')


"rainbow : beautiful Parentheses
"let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle

"----------------------------------------------------------------------------
" DiffRev
" ----------------------------------------------------------------------------
let s:git_status_dictionary = {
            \ "A": "Added",
            \ "B": "Broken",
            \ "C": "Copied",
            \ "D": "Deleted",
            \ "M": "Modified",
            \ "R": "Renamed",
            \ "T": "Changed",
            \ "U": "Unmerged",
            \ "X": "Unknown"
            \ }
function! s:get_diff_files(rev)
  let list = map(split(system(
              \ 'git diff --name-status '.a:rev), '\n'),
              \ '{"filename":matchstr(v:val, "\\S\\+$"),"text":s:git_status_dictionary[matchstr(v:val, "^\\w")]}'
              \ )
  call setqflist(list)
  copen
endfunction

command! -nargs=1 DiffRev call s:get_diff_files(<q-args>)

" ============================================================================
" Functions
" ============================================================================
" Add Functions Here {{{

" SeeTab: toggles between showing tabs and using standard listchars
fu! SeeTab()
  if !exists("g:SeeTabEnabled")
    let g:SeeTabEnabled = 1
    let g:SeeTab_list = &list
    let g:SeeTab_listchars = &listchars
    let regA = @a
    redir @a
    hi SpecialKey
    redir END
    let g:SeeTabSpecialKey = @a
    let @a = regA
    silent! hi SpecialKey guifg=black guibg=magenta ctermfg=black ctermbg=magenta
    set list
    set listchars=tab:\|\
  else
    let &list = g:SeeTab_list
    let &listchars = &listchars
    silent! exe "hi ".substitute(g:SeeTabSpecialKey,'xxx','','e')
    unlet g:SeeTabEnabled g:SeeTab_list g:SeeTab_listchars
  endif
endfunc
com! -nargs=0 SeeTab :call SeeTab()

function! s:get_current_diagnostics() abort
  " Remove entries not belonging to the current file.
  let l:diags = CocAction('jumpReferences')
  echo diags
endfunction


com! -nargs=0 PIKA :call s:get_current_diagnostics()
